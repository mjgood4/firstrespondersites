<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">


    <!-- add title -->
    <title>San Francisco Response Times</title>

    <!-- import required libraries here -->
    <script type="text/javascript" src="lib/d3.v5.min.js"></script>
    <script type="text/javascript" src="lib/d3-dsv.min.js"></script>
    <script type="text/javascript" src="lib/d3-geo-projection.v2.min.js"></script>
    <script type="text/javascript" src="lib/topojson.v2.min.js"></script>
    <script type="text/javascript" src="lib/d3-tip.min.js"></script>
    <script type="text/javascript" src="lib/d3-legend.min.js"></script>

    <style>
        /* define CSS rules here */
    </style>

    <title></title>
</head>


<body>
    <!-- Add heading for the visualization -->
    <h1>San Francisco Response Times Visualization</h1>
    <script>

        const svg = d3
            .select("body")
            .append("svg")
            .attr("id", "map")
            .attr("height", "1000")
            .attr("width", "1200")

        // create the map layers
        const baseMap = svg.append("g").attr("id", "base_map");
        const facilities = svg.append("g").attr("id", "facilities");
        const mapGrid = svg.append("g").attr("id", "map_grid");
        
        Promise.all([
            //d3.dsv(",", "ratings-by-country.csv"),
            d3.json("data/sf_neighborhoods.geojson"),
            d3.json("data/grid_definitions.geojson"),
            d3.json("data/current_fire_stations.geojson"),
            d3.dsv(",", "data/baseline_fca_output.csv")
        ]).then(function (data) {

            const sfMapData = data[0];
            const mapGridData = data[1];
            const sfFacilityData = data[2];
            const baselineFcaOutput = data[3];
            
            const mapCtx = setupMap(sfMapData);
            
            refreshData(mapCtx, {
                sfFacilityData: sfFacilityData,
                mapGridData: mapGridData,
                baselineFcaOutput: baselineFcaOutput
            });
        });

        function refreshData(mapCtx, data) {
            drawFacilities(mapCtx, data.sfFacilityData);
            drawGrid(mapCtx, data.mapGridData, data.baselineFcaOutput)
        }

        function setupMap(geoObj) {
            
            const { height, width } = document.getElementById("map").getBoundingClientRect()
            const projection = d3.geoEquirectangular()            
            projection.fitExtent(
                [
                    [0, 0],
                    [width, height],
                ],
                geoObj
            )            
            const path = d3.geoPath().projection(projection)
            
            baseMap.selectAll("path")
                .data(geoObj.features)
                .enter()
                .append("path")
                .attr("d", (feature) => path(feature))
                .attr("fill", "white")
                .attr("stroke", "gray")

            return {
                projection: projection,
                path: path
            }   
        }

        function drawFacilities(mapCtx, facilityData) {

            facilities.selectAll("path")
                .data(facilityData.features)
                .enter()
                .append("path")
                .attr("d", (feature) => mapCtx.path(feature))
                .attr("fill", "red")
                .attr("stroke", "red")
        }

        function drawGrid(mapCtx, gridDefinition, gridValues) {

            const valMin = d3.min(gridValues, x => Number.parseFloat(x.accessibility_score));
            const valMax = d3.max(gridValues, x => Number.parseFloat(x.accessibility_score));
            const valMid = d3.mean(gridValues, x => Number.parseFloat(x.accessibility_score));
            
            const colorScale = d3.scaleLinear()
                .domain([valMin, valMid, valMax])
                .range(["red", "yellow", "green"]);

            const valLookup = {}
            gridValues.forEach(x=> {
                valLookup[x.zone_idx] = x.accessibility_score;
            })

            mapGrid.selectAll("path")
                .data(gridDefinition.features)
                .enter()
                .append("path")
                .attr("d", (feature) => mapCtx.path(feature))
                .attr("fill-opacity", "0.25")                
                .attr("id", (feature) => {
                    return "zone_idx" + feature.properties.zone_idx;
                })
                .attr("fill", (feature) => {
                    const zoneIdx = feature.properties.zone_idx + "";
                    const zoneVal = valLookup[zoneIdx];
                    if (!zoneVal) {
                        return "white";
                    }
                    else {
                        return colorScale(zoneVal);                        
                    }
                    
                })


        }
        
    </script>
    


</body></html>